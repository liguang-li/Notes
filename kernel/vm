Descibing physical memory

NUMA: non-uniform memory access

With large scale machines, memory may be arranged into banks
that incur a different cost to access depending on the “distance”
from the processor. For example, there might be a bank of memory
assigned to each CPU or a bank of memory very suitable for DMA
near device cards.

Each bank is called a node and the concept is represented under
Linux by a struct pglist_data even if the architecture is UMA.
This struct is always referenced to by it's typedef pg_data_t.

Every node in the system is kept on a NULL terminated list called
pgdat_list and each node is linked to the next with the field 
pg_data_t->node_next. For UMA architectures like PC desktops,
only one static pg_data_t structure called contig_page_data is used. 

Each node is divided up into a number of blocks called zones which
represent ranges within memory. 

Zones should not be confused with zone based allocators as they are
unrelated. 

A zone is described by a struct zone_struct, typedeffed to zone_t
and each one is of type ZONE_DMA, ZONE_NORMAL or ZONE_HIGHMEM.

Each zone type suitable a different type of usage. 
ZONE_DMA is memory in the lower physical memory ranges which certain 
ISA devices require.
Memory within ZONE_NORMAL is directly mapped by the kernel into the 
upper region of the linear address space.
ZONE_HIGHMEM is the remaining available memory in the system and is
not directly mapped by the kernel.

With the x86 the zones are:

ZONE_DMA	First 16MiB of memory
ZONE_NORMAL	16MiB - 896MiB
ZONE_HIGHMEM	896 MiB - End

Each physical page frame is represented by a struct page and all the
structs are kept in a global mem_map array which is usually stored at
the beginning of ZONE_NORMAL or just after the area reserved for the
loaded kernel image in low memory machines.

			pg_data_t
			    |
			node_zones
			    |
	ZONE_DMA	ZONE_NORMAL	ZONE_HIGHMEM
	    |		    |		     |
	node_mem_map	node_mem_map	   node_mem_map
	    |		    |		     |
	   page		   page		    page


Nodes:
Each node in memory is described by a pg_data_t which is a typedef for
a struct pglist_data. When allocating a page, Linux uses a node-local 
allocation policy to allocate memory from the node closest to the running
CPU. As processes tend to run on the same CPU, it is likely the memory 
from the current node will be used. 

The struct is declared as follows in <linux/mmzone.h>

129 typedef struct pglist_data {
130     zone_t node_zones[MAX_NR_ZONES];		//The zones for this node, ZONE_HIGHMEM, ZONE_NORMAL, ZONE_DMA
131     zonelist_t node_zonelists[GFP_ZONEMASK+1];	//his is the order of zones that allocations are preferred from. 
							//A failed allocation in ZONE_HIGHMEM may fall back to ZONE_NORMAL or back to ZONE_DMA;
132     int nr_zones;					//Number of zones in this node, between 1 and 3
133     struct page *node_mem_map;			//
134     unsigned long *valid_addr_bitmap;		//A bitmap which describes “holes” in the memory node that no memory exists for. (Sparc and Sparc64)
135     struct bootmem_data *bdata;			//This is only of interest to the boot memory allocator
136     unsigned long node_start_paddr;			//The starting physical address of the node
137     unsigned long node_start_mapnr;			//gives the page offset within the global mem_map ?
138     unsigned long node_size;			//The total number of pages in this zone
139     int node_id;					//The Node ID (NID) of the node, starts at 0
140     struct pglist_data *node_next;			//Pointer to next node in a NULL terminated list
141 } pg_data_t; 

All nodes in the system are maintained on a list called pgdat_list. 

Initialized by the init_bootmem_core() function.
Macro for_each_online_pgdat() is used to traverse the list
